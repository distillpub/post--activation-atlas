{
  "version": 3,
  "file": "app.css",
  "sources": [
    "../../src/components/AtlasTooltip.html",
    "../../src/library/Tooltip.html",
    "../../src/components/App.html",
    "../../src/Atlas.html",
    "../../src/library/Button.html",
    "../../src/components/AppMiniMap.html",
    "../../src/components/AppLayerChooser.html",
    "../../src/components/AppClassFilter.html",
    "../../src/library/ResponsiveResizer.html",
    "../../src/library/App/Panel.html",
    "../../src/library/D3Zoom.html",
    "../../src/AtlasReticle.html",
    "../../src/library/LazyImage.html",
    "../../src/library/Placeholder.html",
    "../../src/AtlasThumbnail.html",
    "../../src/library/Loading.html"
  ],
  "sourcesContent": [
    "<div class=\"hover\">\n  <table>\n  {#if top_class_indices}\n    {#each top_class_indices.slice(0,5) as top, i}\n      <tr>\n        <td style=\"width: 10px; text-align: right; padding-right: 4px;\">{i + 1}.</td>\n        <td class=\"{i == 0 ? 'first': ''}\">{$inceptionLabels[top]}</td>\n        <td style=\"text-align: right;\">{format(top_class_values[i])}</td>\n      </tr>\n    {/each}\n  {/if}\n  </table>\n  <div style=\"font-size: 10px; margin-top: 4px; color: #999; text-align: right;\">Average of {formatLarge(num_activations)} activations</div>\n\n</div>\n\n<script>\n  import {format} from \"d3-format\";\n\n  export default {\n    helpers: {\n      format: format(\".2f\"),\n      formatLarge: format(\",\")\n    }\n  }\n</script>\n\n<style>\n.hover {\n  margin: 30px;\n  color: white;\n  font-size: 12px;\n  line-height: 14px;\n  background: rgba(0, 0, 0, 0.8);\n  padding: 8px;\n  border-radius: 6px;\n  border: solid 1px rgba(255, 255, 255, 0.4);\n  box-sizing: border-box;\n  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n  z-index: 10000;\n}\n.hover table {\n  width: 100%;\n  margin-bottom: 0;\n}\n.hover td {\n  font-size: 12px;\n  border-bottom: solid 1px rgba(255, 255, 255, 0.2);\n  padding: 6px 0;\n  margin: 6px 0;\n  color: rgba(255, 255, 255, 0.8);\n  overflow: ellipsis;\n}\n.hover td.first {\n  color: rgba(255, 255, 255, 1.0);\n  font-weight: bold;\n}\n\n.icon {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-radius: 4px;\n  border: solid 3px black;\n  pointer-events: none;\n  box-sizing: border-box;\n}\n</style>",
    "<!-- \n  //You first must add one component to the root document.\n  //It will automatically follow the mouse position.\n  //You should also save it to your global store, so all components have access.\n  //You must also pass in what component to use for rendering the data you will pass later.\n\n\t// A global tooltip\n\tstore.set({\n\t\ttooltip: new Tooltip({\n\t\t\ttarget: document.body,\n      store,\n\t\t\tdata: {\n\t\t\t\tcomponent: AtlasTooltip\n\t\t\t}\n\t\t})\n\t});\n\n  //When you want to show it:\n  const { tooltip } = this.store.get();\n  tooltip.show(\n    {\n      message: \"hello\"\n    }\n  );\n\n  //And when you want to hide it: \n  const { tooltip } = this.store.get();\n  tooltip.hide();\n\n -->\n\n<svelte:document on:mousemove=\"mousemove(event)\" on:scroll=\"hide()\"/>\n\n<div ref:root {style}>\n  {#if component}\n    <svelte:component this={component} ref:component/>\n  {/if}\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        visible: false,\n        width: 150,\n        height: 200,\n        component: null,\n      }\n    },\n    computed: {\n      style: ({x, width, y, height, visible}) => {\n        if (visible === false) {\n          return \"display: none;\";\n        } else {\n          const scrollLeft = document.documentElement.scrollLeft;\n          const scrollTop = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);\n          const rightEdge = document.documentElement.clientWidth - width;\n          const bottomEdge = document.documentElement.clientHeight - height;\n          let left = Math.min(x, rightEdge);\n          let top = Math.min(y, bottomEdge);\n          if (x >= rightEdge && y >= bottomEdge) {\n            left = x - width;\n          }\n          return `width: ${width}px; top: ${top + scrollTop}px; left: ${left + scrollLeft}px;`;\n        }\n      },\n    },\n    methods: {\n      mousemove: function(event) {\n        const {visible} = this.get();\n        if (visible) {\n          this.set({\n            x: event.clientX,\n            y: event.clientY\n          });\n        }\n      },\n      show: function(d) {\n        this.set({visible: true});\n        this.refs.component.set(d);\n      },\n      hide: function() {\n        this.set({\n          visible: false\n        });\n        \n      }\n    }\n  }\n</script>\n\n<style>\n  ref:root {\n    box-sizing: border-box;\n    pointer-events: none;\n    z-index: 1000000;\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n</style>",
    "<ResponsiveResizer {clientWidth} {clientHeight} minWidth={768}>\n  <div class=\"container\">\n    <div class=\"filter\" style=\"display: {showClassFilter ? 'block' : 'none'};\">\n      <Panel>\n        <h2 slot=\"head\">Class Filter</h2>\n        <div slot=\"body\">\n          <AppClassFilter\n            bind:classHeatmap\n          />\n        </div>\n      </Panel>\n    </div>\n    <div class=\"stack\" style=\"display: {showLayerChooser ? 'block' : 'none'};\">\n      <Panel>\n        <h2 slot=\"head\">Layer</h2>\n        <div slot=\"body\">\n          <AppLayerChooser\n            bind:layerName\n            {classHeatmap}\n          />\n        </div>\n      </Panel>\n    </div>\n  <div class=\"main\">\n    <div class=\"atlas\">\n        <Atlas\n          ref:atlas\n          id=\"inceptionv1_{layerName}\"\n          strokeColor=\"#666\"\n          backgroundColor=\"#dfdfdf\"\n          showHoverImage={false}\n          bind:density\n          {classHeatmap}\n          bind:iconCrop \n          bind:classHeatmapMultiplier\n          bind:classHeatmapPositive\n          bind:autoGridSizeMultiplier\n          bind:gridSize\n          bind:showLabels\n          bind:enableHover\n          bind:scale\n          bind:gcx\n          bind:gcy\n          bind:extent\n          bind:scrollWheel=\"$scroll\"\n          {homeX}\n          {homeY}\n          {homeScale}\n        />\n        <div ref:controls class=\"controls {showOptions ? 'open' : 'closed'}\">\n          <div class=\"nav\">\n            <div class=\"map\">\n              <div class=\"map-container\" style=\"width: 100px; height: 100px; position: absolute;\">\n                <AppMiniMap \n                  id=\"inceptionv1_{layerName}\"\n                  {layerName}\n                  bind:extent\n                  enableDragging={true}\n                  {classHeatmap}\n                  {scaleCountFactor}\n                  on:drag=\"refs.atlas.translateTo(event.gcx, event.gcy)\"\n                />\n              </div>\n            </div>\n            <div class=\"buttons\">\n              <Button on:click=\"refs.atlas.home(3000)\"><Navigation name=\"home\" color=\"white\"/></Button>\n              <Button on:click=\"refs.atlas.scaleBy(2)\"><Navigation name=\"add\" color=\"white\"/></Button>\n              <Button on:click=\"refs.atlas.scaleBy(0.5)\"><Navigation name=\"remove\" color=\"white\"/></Button>\n            </div>\n          </div>\n          <div class=\"options\">\n            <div class=\"essential\">\n              <label style=\"white-space: nowrap;text-overflow: ellipsis;overflow: hidden;\"><input type=checkbox bind:checked=showLabels> attribution labels</label>\n              <label><input type=checkbox bind:checked=\"enableHover\"> show tooltip</label>\n              <label><input type=checkbox bind:checked=\"$scroll\"> scroll to zoom</label>\n              <button style=\"font-size: 10px; display: {shareLink ? 'block' : 'none'};\" href=\"#\" on:click=\"copyShareLink()\">Copy link to this view</button>\n            </div>\n            <div ref:expand class=\"expand\">\n              <div class=\"grid-size\">\n                \n                <div class=\"section\">\n                  <h3>Grid size</h3>\n                  <label><input type=radio bind:group=gridSize value={0}> 20x20</label>\n                  <label><input type=radio bind:group=gridSize value={1}> 40x40</label>\n                  <label><input type=radio bind:group=gridSize value={2}> 80x80</label>\n                  <label><input type=radio bind:group=gridSize value={3}> 160x160</label>\n                  <label><input type=radio bind:group=gridSize value={4}> 320x320</label>\n                  <label><input type=radio bind:group=gridSize value={-1}> auto</label>\n                  <div style=\"display: {gridSize == -1 ? 'none': 'none'};\">\n                    <div>auto threshold: {@html autoGridSizeMultiplier}</div>\n                    <input type=\"range\" min={0.5} max={1.4} step={0.01} bind:value=autoGridSizeMultiplier>\n                  </div>\n                  </div>\n                <div class=\"section\" >\n                  <h3>Icon density: {@html density}</h3>\n                  <input type=\"range\" min={0.2} max={8} step={0.01} bind:value=density>\n                  <!-- <br>\n                  <div>crop: {@html iconCrop}</div>\n                  <input type=\"range\" min={0} max={0.5} step={0.01} bind:value=iconCrop> -->\n                </div>\n                <div class=\"section\"  style=\"display: {classHeatmap > -1 ? 'block' : 'none'}\">\n                  <h3>Class filter</h3>\n                  <label><input type=radio bind:group=classHeatmapPositive value={1}> positive influence</label>\n                  <label><input type=radio bind:group=classHeatmapPositive value={-1}> negative influence</label>\n                  <div>Intensity: {@html classHeatmapMultiplier}</div>\n                  <input type=\"range\" min=0.5 max=2 step=0.1 bind:value=classHeatmapMultiplier>\n                </div>\n                <div class=\"section\">\n                  <h3>Location</h3>\n                  <div>x: {format(gcx)}</div>\n                  <div>y: {format(gcy)}</div>\n                  <div>scale: {format(scale)}</div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div class=\"expand-toggle\">\n            <button on:click=\"toggle()\">{@html showOptions ? 'fewer options' : 'more options'}</button>\n          </div>\n        </div>\n    </div>\n  </div>\n</div>\n</ResponsiveResizer>\n\n<script>\nimport {format as f} from \"d3-format\";\nimport {locationWithoutQuery} from \"../util.js\";\n\nconst formatFloat = f(\".3f\");\n\nexport default {\n  components: { \n    Button: \"../library/Button.html\",\n    Navigation: \"../library/icons/Navigation.html\",\n    AppMiniMap: \"./AppMiniMap.html\",\n    AppLayerChooser: \"./AppLayerChooser.html\",\n    AppClassFilter: \"./AppClassFilter.html\",\n    Atlas: \"../Atlas.html\",\n    Panel: \"../library/App/Panel.html\",\n    ResponsiveResizer: \"../library/ResponsiveResizer.html\"\n  },\n  data() {\n    return {\n      layerName: \"mixed4c\",\n      gridSize: 1,\n      classHeatmap: -1,\n      iconScaleFactor: 0.8,\n      iconCrop: 0.35,\n      showClassFilter: true,\n      showLayerChooser: true,\n      showOptions: true,\n      homeX: .5,\n      homeY: .5,\n      homeScale: 1,\n      shareLink: false,\n    }\n  },\n  oncreate() {\n    const {loadTarget} = this.get();\n    const query = new URLSearchParams(window.location.search);\n    if (query.has(\"layer\")) {\n      const layerName = decodeURIComponent(query.get(\"layer\"));\n      this.set({layerName});\n    }\n    if (loadTarget) {\n      setTimeout(() => {\n      this.zoomTo(loadTarget.x, loadTarget.y, loadTarget.scale, 0);\n      }, 10);\n    }\n    if (query.has(\"poi\")) {\n      const poiString = query.get(\"poi\");\n      const parts = poiString.split(\",\").map(parseFloat);\n      setTimeout(() => {\n        this.zoomTo(...parts, 4000);\n      }, 1000);\n    }\n  },\n  computed: {\n    realGridSize: ({gridSize}) => (gridSize + 1) * 20,\n    scaleCountFactor: ({iconScaleFactor, realGridSize}) =>  1000000 / (realGridSize * realGridSize * iconScaleFactor)\n  },\n  methods: {\n    home(duration) {\n      this.refs.atlas.home(duration)\n    },\n    zoomTo(x, y, scale, duration = 1000) {\n      this.refs.atlas.zoomTo(x, y, scale, duration);\n    },\n    toggle() {\n      const {showOptions} = this.get();\n      this.set({\n        showOptions: !showOptions\n      });\n    },\n    copyShareLink() {\n      const {layerName} = this.get();\n      const {gcx, gcy, scale} = this.refs.atlas.get();\n      const query = `layer=${encodeURIComponent(layerName)}&poi=${[gcx, gcy, scale].map(formatFloat).join(\",\")}`;\n      const url = locationWithoutQuery() + \"?\" + query;\n      navigator.clipboard.writeText(url).then(function() {\n        console.log(\"Copied to clipboard\");\n      }, function() {\n        console.error(\"Unable to copy to clipboard\");\n      });\n    }\n  },\n  helpers: {\n    format: formatFloat\n  }\n}\n</script>\n\n<style>\n  .container {\n    height: 100%;\n    box-sizing: border-box;\n    grid-column: screen;\n    display: flex;\n    overflow: hidden;\n    contain: strict;\n    font-size: 12px;\n    position: relative;\n  }\n\n  /*  */\n  .filter {\n    width: 120px;\n    border-right: solid 1px rgba(0, 0, 0, 0.2);\n  }\n  .stack {\n    overflow-y: scroll;\n    width: 120px;\n    border-right: solid 1px rgba(0, 0, 0, 0.2);\n    height: 100%;\n  }\n  .main {\n    flex-grow: 1;\n    padding: 8px;\n    box-sizing: border-box;\n    height: 100%;\n  }\n  .atlas {\n    height: calc(100%);\n    position: relative;\n  }\n  /*  */\n\n\n\n  /*  */\n  .controls {\n    position: absolute;\n    box-sizing: border-box;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n    right: 16px;\n    top: 16px;\n    width: 122px;\n    padding: 8px;\n    background-color: white;\n    border-radius: 6px;\n    border: solid 1px rgba(0, 0, 0, 0.2);\n    line-height: 1.7em;\n    font-size: 10px;\n    display: flex;\n    flex-direction: column;\n    max-height: calc(100% - 48px);\n  }\n\n  ref:controls label {\n    display: block;\n    color: rgba(0, 0, 0, 0.7);\n  }\n  \n  ref:controls .nav {\n    flex: 0 0 auto;\n    display: flex;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n    padding-bottom: 8px;\n  }\n  ref:controls .nav .map {\n    position: relative;\n    visibility: hidden;\n    width: 0;\n    height: 0;\n    pointer-events: none;\n  }\n  ref:controls .nav .buttons {\n    width: 100%;\n    justify-items: center;\n    display: grid;\n    grid-gap: 4px;\n    grid-auto-columns: auto;\n    grid-auto-flow: column;\n  }\n  ref:controls .expand-toggle {\n    flex: 0 0 auto;\n    /* border-top: solid 1px rgba(0, 0, 0, 0.1); */\n    /* padding-top: 8px; */\n  }\n  ref:controls .expand-toggle button {\n    display: block;\n    width: 100%;\n    line-height: 1.5em;\n    font-size: 10px;\n  }\n\n  ref:controls .section {\n    margin-top: 8px;\n    border-top: solid 1px rgba(0, 0, 0, 0.1);\n    padding-top: 8px;\n    color: rgba(0, 0, 0, 0.7);\n  }\n\n  ref:controls .section h3 {\n    color: rgba(0, 0, 0, 1);\n    margin: 0 0 4px 0;\n    font-weight: 500;\n    text-transform: uppercase;\n    font-size: 11px;\n  }\n\n  ref:controls .options {\n    flex: 1 1;\n    overflow-y: scroll;\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n  ref:controls.closed .expand {\n    height: 0;\n    overflow: hidden;\n  }\n  ref:controls.open .expand {\n    height: auto;\n  }\n  ref:controls.open .options {\n    margin-bottom: 8px;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n  }\n  @media(min-width: 800px) {\n    .filter {\n      width: 170px;\n    }\n    .stack {\n      width: 170px;\n    }\n    .controls {\n      width: 160px;\n    }\n    ref:controls .nav .map {\n      visibility: visible;\n      height: auto;\n      width: 104px;\n      margin-right: 8px;\n      pointer-events: all;\n    }\n    ref:controls .nav .buttons {\n      width: inherit;\n      grid-auto-flow: row;\n    }\n  }\n\n</style>\n",
    "<svelte:window on:resize=\"measure()\" />\n<Radar bind:ready />\n\n\n{#if ready}\n  <AtlasDataLoader \n    {id} \n    {layer} \n    {layout}\n    {classFilter}\n    {filter}\n    bind:config\n    bind:layers \n    bind:labels \n    bind:loading\n  />\n{/if}\n\n<div ref:root\n>\n  <D3Zoom ref:d3Zoom\n    clientWidth={viewWidth}\n    clientHeight={viewHeight}\n    bind:scale\n    bind:translateX\n    bind:translateY\n    bind:mouseOver\n    bind:mouseGlobalPosition\n    bind:extent\n    bind:scrollWheel\n    bind:disableBehaviors\n    bind:gcx\n    bind:gcy\n    {homeX}\n    {homeY}\n    {homeScale}\n  >\n    <canvas ref:canvas\n      width={viewWidth * screenResolution}\n      height={viewHeight * screenResolution}\n    ></canvas>\n    <canvas ref:labelsCanvas\n      width={viewWidth * screenResolution}\n      height={viewHeight * screenResolution}\n    ></canvas>\n    {#if showHoverIcon}\n    <div ref:hover\n      style=\"left: {hoverIconX}px; top: {hoverIconY}px; width: {hoverIconW}px; height: {hoverIconW}px;\"\n    ></div>\n    {/if}\n  </D3Zoom>\n</div>\n\n<script>\nimport { default as load } from './library/load.js';\nimport { max } from 'd3-array';\n\nexport default {\n  components: { \n    AtlasDataLoader: './AtlasDataLoader.html', \n    D3Zoom: './library/D3Zoom.html',\n    Radar: './library/Radar.html'\n  },\n  data() {\n    return {\n      ready: true,\n      id: \"inceptionv1_mixed4c\",\n\n      // viewWidth: 500,\n      // viewHeight: 500,\n      \n      config: null,\n      layers: null,\n\n      layer: 0,\n      layout: 0,\n      classFilter: 0,\n      filter: 0,\n\n      context: null,\n\n      alphaAttributionFactor: 0.02,\n      density: 1.0,\n      classHeatmap: -1,\n      classHeatmapMultiplier: 1,\n      classHeatmapPositive: 1,\n      iconCrop: 0.02,\n      autoGridSizeMultiplier: 0.5,\n\n      gridSize: null,\n\n      // for initial state, and going back to \"home\"\n      homeX: .5,\n      homeY: .5,\n      homeScale: 1,\n\n      // turn off features\n      enableClickToZoom: true,\n      enableHover: true,\n      enableDragToPan: true,\n\n      // Styling\n      backgroundColor: \"white\",\n      strokeColor: \"rgb(220, 220, 220)\",\n      strokeThickness: 1,\n      imageSmoothing: false,\n      fontSize: 10,\n      textColor: \"white\",\n      textShadowColor: \"rgba(0, 0, 0, 0.6)\",\n      showLabels: true,\n\n      screenResolution: 1,\n    }\n  },\n  computed: {\n    maxAttributionValue: ({layers, layer}) => {\n      if (layers == null) return 0;\n      const l = layers[layer];\n      let max = 0;\n      l.forEach(x => {\n        x.forEach(y => {\n          if (y && y.num_activations > 500) {\n            const v = y.full_class_values[0];\n            if (v > max) max = v;\n          }\n        })\n      })\n      return max;\n    },\n    w: ({viewWidth, screenResolution}) => viewWidth * screenResolution,\n    h: ({viewHeight, screenResolution}) => viewHeight * screenResolution,\n    currentZoomIndex: ({scale, gridSize, config, classHeatmap, w, h, autoGridSizeMultiplier}) => {\n      let s = 0;\n      if (gridSize > -1) {\n        s = +gridSize\n      } else {\n        const size = Math.max(w, h);\n        const optimalNumIcons = ((size * scale) / 80) / autoGridSizeMultiplier;\n        const snapToGrid = Math.floor(Math.sqrt(optimalNumIcons / 20));\n        s = snapToGrid;\n      }\n      // Make sure we don't overrun our data\n      if (config) {\n        s = Math.min(config.grid_size.length - 1 , s);\n      }\n      // Class heatmap only has data up to level 2\n      if (classHeatmap > -1) {\n        s = Math.min(2, s);\n      }\n      return s;\n\n    },\n    // visibleLayers: ({currentZoomIndex}) => {\n    //   return [{i: currentZoomIndex, opacity: 1}];\n    // },\n    currentLayerData: ({currentZoomIndex, layers}) => {\n      return layers ? layers[currentZoomIndex] : [[]]\n    },\n    labelsBuffer: ({labelsBufferContext, labels, fontSize, textColor, textShadowColor}) => {\n      // console.log(labelsBufferContext, labels);\n    \n      if (labelsBufferContext && labels) {\n        labelsBufferContext.globalAlpha = 1.0;\n        labelsBufferContext.font=fontSize + \"px Helvetica\";\n        labels.forEach((label, i) => {\n          // if (textShadow) {\n          labelsBufferContext.lineWidth = 3;\n          labelsBufferContext.lineJoin = \"round\"\n          labelsBufferContext.strokeStyle = textShadowColor;\n          labelsBufferContext.strokeText(label, (i % 10) * 150 + 10, Math.floor(i / 10 + 1) * 20, 80, 15);\n          // }\n          labelsBufferContext.fillStyle = textColor;\n          labelsBufferContext.fillStyle = textColor;\n          labelsBufferContext.fillText(label, (i % 10) * 150 + 10, Math.floor(i / 10 + 1) * 20, 80, 15);\n                        \n        });\n      }\n    },\n    showHover: ({hoverIconData, mouseGlobalPosition}) => mouseGlobalPosition && hoverIconData && hoverIconData.gcx,\n    hoverIconData: ({currentLayerData, config, mouseGlobalPosition, w, h, translateX, translateY}) => {\n      // const msx = mouseGlobalPosition[0]\n      // const msy = mouseGlobalPosition[1]\n      if (currentLayerData) {\n        const numGridRows = currentLayerData.length;\n        if (mouseGlobalPosition) {\n          const gx = Math.floor(mouseGlobalPosition[0] / Math.min(w, h) * numGridRows);\n          const gy = Math.floor(mouseGlobalPosition[1] / Math.min(w, h) * numGridRows);\n          if (currentLayerData[gy] && currentLayerData[gy][gx]) {\n            return currentLayerData[gy][gx];\n          } else {\n            return {};\n          }\n        } else {\n          return {};\n        }\n      } else {\n        return {};\n      }\n    },\n    hoverIconX: ({hoverIconData, scale, w, h, translateX}) => hoverIconData.gy * scale * Math.min(w, h) + translateX,\n    hoverIconY: ({hoverIconData, scale, w, h, translateY}) => hoverIconData.gx * scale * Math.min(w, h) + translateY,\n    hoverIconW: ({hoverIconData, scale, w, h}) => hoverIconData.gw * scale * Math.min(w, h),\n    showHoverIcon: ({mouseGlobalPosition, hoverIconData, enableHover}) => {\n      return enableHover && mouseGlobalPosition && hoverIconData && hoverIconData.gw\n    },\n  },\n  onupdate({changed, current, previous}) {\n    // console.log(\"atlas\", changed, current.scale)\n    if (!current.context || changed.viewWidth || changed.viewHeight) {\n      const labelsContext = this.refs.labelsCanvas.getContext('2d');\n      labelsContext.imageSmoothingEnabled = false;\n      this.set({\n        context: this.refs.canvas.getContext('2d'),\n        labelsContext\n      });\n    }\n    if (changed.loading || changed.autoGridSizeMultiplier || changed.labels || changed.density || changed.maxAttributionValue || changed.classHeatmap || changed.classHeatmapMultiplier || changed.classHeatmapPositive || changed.showLabels || changed.viewWidth || changed.viewHeight || changed.scale || changed.translateX || changed.translateY || changed.iconCrop || changed.gridSize || changed.layers) {\n      this.render();\n    }\n    if (changed.hoverIconData) {\n      const {tooltip} = this.store.get();\n      const {showHoverIcon} = this.get();\n      if (showHoverIcon) {\n        tooltip.show(current.hoverIconData);\n      } else {\n        tooltip.hide();\n      }\n    }\n    if (changed.showHoverIcon) {\n      if (current.showHoverIcon == false) {\n        const { tooltip } = this.store.get();\n        tooltip.hide();\n      }\n    }\n\n  },\n  oncreate() {\n    // Turn off tooltips while zooming\n    const {tooltip} = this.store.get();\n    this.refs.d3Zoom.on(\"zoom\", () => {\n      tooltip.hide();\n    });\n    // Offscreen buffer for drawing text labels;\n    const labelsBufferCanvas = document.createElement(\"canvas\");\n    labelsBufferCanvas.width = 150 * 10;\n    labelsBufferCanvas.height = (Math.ceil(1002 / 10) + 1) * 20;\n    const labelsBufferContext = labelsBufferCanvas.getContext(\"2d\");\n    this.set({labelsBufferCanvas, labelsBufferContext});\n    setTimeout(() => {\n      this.measure();\n      this.home();\n    }, 10);\n  },\n  methods: {\n    measure() {\n      this.set({\n        viewWidth: this.refs.root.offsetWidth,\n        viewHeight: this.refs.root.offsetHeight,\n      })\n    },\n    fullscreen() {\n      this.refs.root.webkitRequestFullscreen();\n    },\n    home(duration=0) {\n      // const {homeX, homeY, homeScale} = this.get();\n      // this.transitionTo(homeX, homeY, homeScale, duration);\n      this.refs.d3Zoom.home(duration);\n    },\n    translateTo(x, y) {\n      this.refs.d3Zoom.translateTo(x, y);\n    },\n    zoomTo(x, y, scale, duration = 1000) {\n      this.refs.d3Zoom.zoomTo(x, y, scale, duration);\n    },\n    transitionTo(x, y, scale, duration=0) {\n      this.refs.d3Zoom.transformTo(x, y, scale, duration);\n    },\n    scaleBy(multiplier) {\n      const { scale } = this.get();\n      this.refs.d3Zoom.scaleTo(scale * multiplier, 300);\n    },\n    iconToGlobalPosition(icon, layerIndex) {\n      const {density, scale, translateX, translateY, config, w, h} = this.get();\n      const gridSize = config.grid_size[layerIndex];\n      const gridWidth = config.icon_size * gridSize;\n\n      const iconWidth = icon.gw * scale * Math.min(w, h);\n\n      // x, y swapped intentionally\n      const iconX = icon.gy * scale * Math.min(w, h) + translateX;\n      const iconY = icon.gx * scale * Math.min(w, h) + translateY;\n\n      const sourceX = icon.localX * config.icon_size;\n      const sourceY = icon.localY * config.icon_size;\n\n      const totalSamples = (typeof config.filter[0] == \"number\" ? config.filter[0] : config.sample_images)\n      const avgSamples = totalSamples / (gridSize * gridSize);\n\n      // Resize based on density\n      const relativeDensity = Math.min(1, Math.sqrt(density * icon.num_activations / avgSamples));\n      const adjustedIconWidth = iconWidth * relativeDensity;\n      const adjustedIconX = iconX + (iconWidth - adjustedIconWidth) / 2;\n      const adjustedIconY = iconY + (iconWidth - adjustedIconWidth) / 2\n\n      return {sourceX, sourceY, iconX: adjustedIconX, iconY: adjustedIconY, iconWidth: adjustedIconWidth}\n    },\n    clear() {\n      const {viewHeight, viewWidth, context, backgroundColor, labelsContext} = this.get();\n      context.globalAlpha = 1;\n      context.fillStyle= backgroundColor;\n      context.clearRect(0, 0, viewWidth, viewHeight);\n      context.fillRect(0, 0, viewWidth, viewHeight);\n      labelsContext.globalAlpha = 1;\n      labelsContext.clearRect(0, 0, viewWidth, viewHeight);\n    },\n    render() {\n\n      const {id, labelsContext, loading, classHeatmap, showLabels, labels, labelsBufferCanvas, imageSmoothing, scale, w, h, translateX, translateY, context, backgroundColor, config, layers, visibleLayers, currentZoomIndex, strokeColor, strokeThickness, fontSize,textShadowColor, textColor, maxAttributionValue, classHeatmapMultiplier} = this.get();\n\n      this.clear();\n      // context.imageSmoothingQuality = \"low\";\n      context.imageSmoothingEnabled = imageSmoothing;\n\n      labelsContext.strokeStyle = strokeColor;\n      labelsContext.lineWidth = strokeThickness;\n      context.fillStyle = \"white\";\n\n      if (config && layers && !loading) {\n        let visibleLayers = [\n          {i: currentZoomIndex, opacity: 1.0}\n        ];\n        this.set({visibleLayers});\n\n        visibleLayers.forEach(visibleLayer => {\n          const layerIndex = visibleLayer.i;\n          const layerOpacity = visibleLayer.opacity;\n          const icons = layers[layerIndex];\n\n            \n            // Calculating min and max indices for icon render loop\n            const minSize = Math.min(w, h);\n            const minX = Math.max(0, Math.floor(-(translateX / scale / minSize) * icons.length));\n            const maxX = minX + Math.ceil(( w / scale / minSize) * icons.length);\n            const minY = Math.max(0, Math.floor(-(translateY / scale / minSize) * icons.length));\n            const maxY = minY + Math.ceil(( h / scale / minSize) * icons.length);\n\n            for (let y = minY; y <= maxY; y++) {\n              for (let x = minX; x <= maxX; x++) {\n                \n                if (icons[y] && icons[y][x]) {\n                  const icon = icons[y][x];\n\n                  const {sourceX, sourceY, iconX, iconY, iconWidth} = this.iconToGlobalPosition(icon, layerIndex);\n                  \n                  const requestedID = id;\n                  // If icon is in the viewport \n                  // probably don't need this anymore\n                  // if (iconX > -iconWidth && iconX < w && iconY > -iconWidth && iconY < h) {\n                  if (true) {\n                    \n                    // We want to draw a box so there isn't just whiteness.\n                    if (classHeatmap > -1 || true) {\n                      labelsContext.globalAlpha = 0.3;\n                      labelsContext.strokeRect(iconX, iconY, iconWidth, iconWidth);\n                      labelsContext.globalAlpha = 1.0;\n                    }\n                    const textSkipX = Math.ceil(40 / iconWidth);\n                    const textSkipY = Math.ceil(60 / iconWidth);\n                    if (showLabels && labels && classHeatmap === -1 && icon.y % textSkipY == 0 && icon.x % textSkipX == 0 ) {\n                      labelsContext.globalAlpha = 1;\n                      const labelIndex = icon.top_class_indices[0];\n                      labelsContext.drawImage(\n                        labelsBufferCanvas,\n                        //source\n                        (labelIndex % 10) * 150, Math.floor(labelIndex / 10) * 20 + 4, Math.min(iconWidth * textSkipY - 5, 100), 20,\n                        //destination\n                        iconX, iconY + iconWidth - 20 - 2, Math.min(iconWidth * textSkipY - 5, 100), 20\n                      );\n                    }\n\n                    load(icon.url).then(response => {\n                      \n                      // check that we're still on the right layer/zoom/id\n                      const {id, visibleLayers, iconCrop, showLabels, textShadow} = this.get();\n                      // console.log(requestedID, id)\n\n                      if(visibleLayers.reduce((acc, layer) => layer.i === layerIndex ? acc + 1 : acc, 0) && requestedID === id) {\n                        const {labelsContext, labelsBufferCanvas, alphaAttributionFactor, labels, config, classHeatmap, classHeatmapMultiplier, classHeatmapPositive} = this.get();\n\n                        const {sourceX, sourceY, iconX, iconY, iconWidth} = this.iconToGlobalPosition(icon, layerIndex);\n\n                        // If we have a class heatmap active, calculate the transparency for the current icon\n                        let a = 1;\n                        if (classHeatmap > -1) {\n                          let i = icon.full_class_indices.indexOf(classHeatmap);\n                          if (i > -1) {\n                            a = icon.full_class_values[i] / maxAttributionValue;\n                            a = a * classHeatmapPositive;\n                            a = Math.max(0, a) * classHeatmapMultiplier;\n                          } else {\n                            a = 0.0;\n                          }\n                          \n                        }\n                        const computedIconCrop = Math.min(8 / iconWidth, 0.6);\n                        // draw the icon\n                        context.globalAlpha = 1;\n                        const iconOffset = (computedIconCrop * config.icon_size) / 2;\n                        // context.clearRect(iconX + 1, iconY + 1, iconWidth - 2, iconWidth - 2);\n                        if (classHeatmap > -1) {\n                          // labelsContext.beginPath();\n                          context.fillRect(iconX, iconY, iconWidth, iconWidth);\n                          // context.fill();\n                          // context.closePath();\n                        }\n                        context.globalAlpha = a;\n                        context.drawImage(response,\n                          //source\n                          sourceY + iconOffset, sourceX + iconOffset, config.icon_size - iconOffset * 2, config.icon_size - iconOffset * 2,\n                          //destination\n                          iconX, iconY, iconWidth, iconWidth\n                        );\n                        \n                        // context.globalAlpha = 1;\n                        // context.closePath();\n                        \n                      }\n                    })\n                  }\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n  }\n\n</script>\n\n\n<style>\n  ref:root {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    contain: layout;\n    overflow: hidden;\n  }\n  ref:stage {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n  ref:canvas, ref:labelsCanvas {\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 8px;\n  }\n  ref:hover {\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 4px;\n    border: solid 3px black;\n    pointer-events: none;\n    box-sizing: border-box;\n  }\n</style>\n",
    "<button\n  on:click=\"fire('click')\"\n  style=\"\n    background-color: {backgroundColor};\n    color: {color};\n  \"\n>\n  <slot></slot>\n</button>\n\n<script>\nexport default {\n  data() {\n    return {\n      backgroundColor: \"rgb(255, 130, 0)\",\n      color: \"white\",\n    }\n  }\n}\n\n</script>\n\n<style>\n  button {\n    /* border: solid 2px rgb(255, 130, 0); */\n    outline: none;\n    font-size: 13px;\n    border: none;\n    padding: 0 4px;\n    font-weight: 500;\n    height: 32px;\n    line-height: 1em;\n    border-radius: 4px;\n    text-transform: uppercase;\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    vertical-align: middle;\n    -webkit-font-smoothing: antialiased;\n    margin: 0;\n  }\n</style>",
    "<div ref:root>\n  <Placeholder>\n    <div style=\"opacity: 0.4;\">\n      <LazyImage aspectRatio={1} src=\"assets/images/renders/thumbnail-{layerName}.jpg\" border={false} alt=\"thumbnail for {layerName}\" />\n    </div>\n    <AtlasReticle\n      bind:extent\n      enableDragging={true}\n      on:drag=\"fire('drag', event)\"\n    />\n  </Placeholder>\n</div>\n\n<script>\n  export default {\n    components: {\n      AtlasReticle: \"../AtlasReticle.html\",\n      LazyImage: \"../library/LazyImage.html\",\n      Placeholder: \"../library/Placeholder.html\"\n    },\n    data() {\n      return {\n        scaleCountFactor: 200\n      }\n    }\n  }\n</script>\n\n<style>\nref:root {\n  position: relative;\n  width: 100%; \n  height: 100%;\n  box-sizing: border-box;\n  padding: 1px;\n}\n</style>",
    "<div class=\"stack\">\n{#each layers as layer, i}\n  <label class=\"layer {layerName == layer ? 'selected' : ''}\">\n    <input type=radio bind:group=layerName value={layer}>\n    <div class=\"thumb\" style=\"position: relative;\">\n      <AtlasThumbnail grid={0} layerName={layer} {classHeatmap}/>\n    </div>\n    <span>{layer}</span>\n  </label>\n{/each}\n</div>\n\n<script>\n  export default {\n    components: {\n      AtlasThumbnail: \"../AtlasThumbnail.html\"\n    },\n    data() { return {\n      layerName: \"mixed4c\",\n      layers: [\n        \"mixed3a\",\n        \"mixed3b\",\n        \"mixed4a\",\n        \"mixed4b\",\n        \"mixed4c\",\n        \"mixed4d\",\n        \"mixed4e\",\n        \"mixed5a\",\n        \"mixed5b\",\n      ],\n      classHeatmap: -1\n    }; }\n  }\n</script>\n\n<style>\n.layer {\n  position: relative;\n  cursor: pointer;\n  display: grid;\n  align-items: center;\n  grid-template-columns: 1fr 1.5fr;\n  font-size: 11px;\n  text-transform: uppercase;\n  padding: 5px 16px 5px 16px;\n  color: grey;\n  border-left: solid 3px rgba(255, 255, 255, 0);\n  border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n}\n.layer input {\n  position: absolute;\n  opacity: 0;\n}\n.layer span {\n  margin-left: 8px;\n}\n.layer.selected {\n  border-left-color: rgb(255, 130, 0);\n  color: rgb(255, 130, 0);\n  background-color: rgba(255, 130, 0, 0.08);\n  font-weight: bold;\n}\n.layer :global(canvas) {\n  opacity: 0.5;\n}\n.layer.selected :global(canvas) {\n  /* opacity: 1; */\n}\n.thumb {\n  width: 30px;\n  position: relative;\n}\n@media(min-width: 800px) {\n  .thumb {\n    width: 45px;\n  }\n}\n</style>",
    "<div class=\"chooser\">\n  {#each labels as l}\n    <label class=\"{classHeatmap === l.i ? 'selected' : ''}\">\n      <input type=radio bind:group=classHeatmap value={l.i}>\n      <span title=\"{l.i}\">{l.label}</span>\n    </label>\n  {/each}\n</div>\n\n<script>\nimport classesToKeep from './../classesToKeep.js';\nimport inceptionLabels from './../Labels.js';\n\nexport default {\n  data() {\n    return {\n      classesToKeep,\n      inceptionLabels,\n      classHeatmap: 235\n    }\n  },\n  computed: {\n    labels: ({inceptionLabels}) => {\n      let out = classesToKeep.map(k => {\n        let l = inceptionLabels.inception[k];\n        return {label: l, i: k};\n      });\n      return [{label: \"show all\", i: -1}].concat(out);\n    }\n  }\n}\n</script>\n\n<style>\n  .chooser {\n    height: auto;\n  }\n  .chooser label {\n    position: relative;\n    font-size: 11px;\n    line-height: 1.2em;\n    display: block;\n    border-left: solid 3px white;\n    padding: 5px 16px 5px 16px;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-y: hidden;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n  }\n  .chooser label input {\n    position: absolute;\n    opacity: 0;\n  }\n  .chooser label.selected {\n    border-left-color: rgb(255, 130, 0);\n    color: rgb(255, 130, 0);\n    background-color: rgba(255, 130, 0, 0.08);\n    font-weight: bold;\n  }\n</style>",
    "<!-- \n  Will start to add a transform: scale(...) when the width gets smaller than\n  the provided minWidth parameter.\n  clientWidth and clientHeight are otherwise respected.\n\n  another idea:\n  have a style parameter \n  and minWidth + aspectRatio.\n  if < minWidth, aspectRation, othewise use style.\n -->\n\n<div ref:root>\n  <div\n    ref:frame\n    style=\"\n      transform: scale({scale});\n      width: {finalWidth};\n      height: {finalHeight};\n      {style}\n    \"\n  >\n    <slot></slot>\n  </div>\n</div>\n\n<script>\nexport default {\n  data() {\n    return {\n      style: \"\",\n      aspectRatio: 1,\n      minWidth: 800,\n      clientWidth: 1000,\n      clientHeight: 1000,\n    }\n  },\n  computed: {\n    scale: ({clientWidth, minWidth}) => clientWidth / Math.max(clientWidth, minWidth),\n    finalWidth: ({clientWidth, width, minWidth}) => {\n      return Math.max(clientWidth, minWidth) + \"px\";\n    },\n    finalHeight: ({clientHeight, scale}) => {\n      return clientHeight / scale + \"px\";\n    }\n  }\n}\n</script>\n\n\n<style>\n  ref:root {\n    width: 100%;\n    position: relative;\n  }\n  ref:frame {\n    transform-origin: top left;\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n</style>",
    "<div class=\"root\">\n  <div class=\"head\">\n    <slot name=\"head\"></slot>\n  </div>\n  <div class=\"body\">\n    <slot name=\"body\"></slot>\n  </div>\n</div>\n\n<style>\n  .root {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n  }\n  :global() .head {\n    height: 60px;\n    padding: 0 16px;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.2);\n    /* box-sizing: border-box; */\n    display: flex;\n    align-items: center;\n    flex: 0 0 60px;\n  }\n  :global() .head h2 {\n    font-size: 16px;\n    font-weight: bold;\n    line-height: 1.4em;\n    margin: 0;\n    padding: 0;\n    border: none;\n  }\n  :global() .body {\n    position: relative;\n    flex: 1;\n    overflow-y: scroll;\n    font-size: 11px;\n    line-height: 1.6em;\n  }\n  :global() .body h3 {\n    font-size: 12px;\n    font-weight: 600;\n    line-height: 1.2em;\n    text-transform: uppercase;\n    margin: 8px 0;\n    height: auto;\n    border-top: solid 1px rgba(0, 0, 0, 0.1);\n    padding-top: 1em;\n  }\n</style>",
    "<div \n  ref:root \n  class=\"d3zoom\" \n  on:mousemove=\"mouseMove(event)\"\n  on:mousedown=\"set({msx: null, msy: null})\"\n  on:mouseout=\"set({msx: null, msy: null})\"\n>\n  <slot />\n</div>\n\n<script>\nimport {zoomIdentity as d3ZoomIdentity, zoom as d3Zoom, zoomTransform as d3ZoomTransform} from \"d3-zoom\";\nimport {event as d3Event, select as d3Select} from \"d3-selection\";\nimport { tween } from 'svelte-extras';\nimport * as eases from 'eases-jsnext';\n\nexport default {\n  data() {\n    return {\n      z: d3Zoom(), //d3 zoom object\n      el: null,\n      selection: null, //the d3 selection of the root\n      transform: null, // the d3 transform\n      scaleExtent: [1, 48], //\n      homeScale: 1,\n      homeX: 0.5,\n      homeY: 0.5,\n      scale: null,\n      translateX: null,\n      translateY: null,\n      k: 1,\n      x: 0,\n      y: 0,\n      msx: null,\n      msy: null,\n      disableBehaviors: false,\n      scrollWheel: false,\n    };\n  },\n  computed: {\n    minSize: ({clientWidth, clientHeight}) => Math.min(clientWidth, clientHeight),\n    mouseOver: ({msx, msy}) => msx != undefined && msy != undefined,\n    mouseGlobalPosition: ({transform, msx, msy, clientHeight, clientWidth, minSize}) => {\n      if (transform && msx != undefined && msy != undefined) {\n        return [\n          transform.invertX(msx),// - (clientWidth - minSize) / 2,\n          transform.invertY(msy),// - (clientHeight - minSize) / 2,\n        ];\n      } else {\n        return null;\n      }\n    },\n    extent: ({scale, translateX, translateY, minSize, clientWidth, clientHeight}) => {\n      const x0 = - translateX / scale;\n      const y0 = - translateY / scale;\n      const x1 = x0 + clientWidth / scale;\n      const y1 = y0 + clientHeight / scale;\n      return [\n        [x0 / minSize, x1 / minSize],\n        [y0 / minSize, y1 / minSize],\n      ]\n    },\n    gcx: ({extent}) => (extent[0][0] + extent[0][1]) / 2,\n    gcy: ({extent}) => (extent[1][0] + extent[1][1]) / 2,\n  },\n  \n  oncreate() {\n    const {z, scaleExtent, minSize, clientWidth, clientHeight, homeScale, homeX, homeY, disableBehaviors} = this.get();\n    const that = this; // needed because d3 gives \"this\" as the node, not component.\n    z.wheelDelta(() => {\n      let d = -d3Event.deltaY * (d3Event.deltaMode ? 120 : 1) / 500;\n      if (d3Event.ctrlKey) {\n        d = d * 10;\n      }\n      return d;\n    });\n    z.scaleExtent(scaleExtent);\n    const selection = d3Select(this.refs.root);\n    this.set({\n      selection,\n      el: this.refs.root,\n    });\n    if (!disableBehaviors) {\n      z(selection);\n    }\n    z.filter(this.zoomEventFilter.bind(this));\n    z.on(\"zoom\", () => { this.onzoom(that); });\n    z.translateTo(selection, homeX * minSize, homeY * minSize)\n    z.scaleTo(selection, homeScale);\n  },\n  onstate({changed, current, previous}) {\n    if (previous != undefined) {\n      if ((changed.clientWidth || changed.clientHeight) && current.el) {\n        this.update();\n      }\n    }\n    // console.log(\"update\", changed, current.scale)\n    const {z, selection, el, x, y} = this.get();\n    // if (changed.scaleExtent && current.scaleExtent) { z.scaleExtent(current.scaleExtent) } \n    if (selection) {\n\n      // if (changed.x || changed.y) {\n      //   z.translateTo(selection, current.x, current.y);\n      // }\n\n      // if (changed.scale) { this.set({k: current.scale}); }\n      // if (changed.k) { z.scaleTo(selection, current.k); } \n\n      // if (changed.translateX) { this.set({x: current.translateX}); }\n      // if (changed.translateY) { this.set({x: current.translateY}); }\n\n    }\n  },\n  methods: {\n    tween,\n    zoomEventFilter: function() {\n      const {scrollWheel, touchPan, disableBehaviors} = this.get();\n      // console.log(d3Event)\n      if (disableBehaviors) {\n        return false;\n      }\n      // if (!touchPan && d3Event.touches) {\n      //   if (d3Event.touches.length === 1) {\n      //     return false;\n      //   }\n      // }\n      // If we want to suppress scroll wheel events...\n      if (!scrollWheel) {\n        // ... return false for scroll wheel events + button = 1 events\n        return !(d3Event.type === \"wheel\" && d3Event.ctrlKey === false) && !d3Event.button;\n      } else {\n        //... just return false for button = 1 events\n        return !d3Event.button;\n      }\n    },\n    mouseMove: function(event) {\n      const msx = event.offsetX;\n      const msy = event.offsetY;\n      this.set({\n        msx, msy\n      });\n      const {mouseGlobalPosition} = this.get();\n    },\n    update: function() {\n      \n      const {clientWidth, clientHeight, minSize, el, z} = this.get();\n      const transform = d3ZoomTransform(el);\n      // console.log(\"update\", transform.k)\n      const scale = transform.k;\n      this.set({\n        scale,\n        transform,\n        translateX: transform.x, // + scale * (clientWidth - minSize) / 2,\n        translateY: transform.y, // + scale * (clientHeight - minSize) / 2,\n      });\n    },\n    onzoom: function(that) {\n      // console.log(\"onzoom\")\n      that.update();\n      that.fire(\"zoom\");\n    },\n    zoomTo: function(x, y, scale = 1, duration = 1000) {\n      const {selection, z, minSize, clientWidth, clientHeight} = this.get();\n\n      selection.transition()\n        .duration(duration)\n        .call(z.transform, \n          d3ZoomIdentity\n            .translate(clientWidth / 2, clientHeight / 2)\n            .scale(scale)\n            .translate(- x * minSize, - y * minSize));\n    },\n    translateTo: function(x, y) {\n      const {z, selection, minSize} = this.get();\n      z.translateTo(selection, x * minSize, y * minSize)\n    },\n    home: function(duration=0) {\n\n      const {homeX, homeY, homeScale} = this.get();\n      this.zoomTo(homeX, homeY, homeScale, duration)\n\n      // selection.transition()\n      //   .duration(duration)\n      //   .call(z.transform, \n      //     d3ZoomIdentity\n      //       .translate(clientWidth / 2, clientHeight / 2)\n      //       .translate(- 0.5 * minSize, - 0.5 * minSize));\n    },\n    scaleTo: function(scale, duration=0) {\n      // console.log(\"scaleTo\", duration)\n      const {z, selection} = this.get();\n      selection.transition()\n        .duration(duration)\n        .call(z.scaleTo, scale);\n    }\n  }\n}\n</script>\n\n<style>\nref:root {\n  position: relative;\n  background: white;\n  width: 100%;\n  height: 100%;\n}\n</style>",
    "\n<svelte:window on:resize=\"measure()\" />\n\n<div \n  ref:root\n  class=\"root\" \n  on:pointerdown=\"down(event)\"\n  style=\"cursor: {cursor}; position: absolute;\"\n>\n  {#if extent}\n  <svg width={clientWidth} height={clientHeight}>\n    {#if left && right && top && bottom}\n      <path\n        class=\"{background ? '' : 'transparent'}\"\n        d=\"M0,0 L{clientWidth},0 L{clientWidth},{clientHeight} L0,{clientHeight} z M{left},{top} L{left},{bottom} L{right},{bottom} L{right},{top} z\"\n      />\n    {/if}\n  </svg>\n  <div\n    class=\"reticle {round ? 'round' : ''}\"\n    style=\"\n      border-color: {color};\n      top:{top - 1}px;\n      left:{left - 1}px; \n      width:{right - left + 2}px; \n      height:{bottom - top + 2}px; \n      \"\n  >\n    {#if annotationValue}\n      <div class=\"annotationTabParent\" style=\"top:{(w * width-2)/2}px;\">\n        <div class=\"annotationTab\" style=\"background:{color};\">\n          <div class=\"annotation\">{annotationValue}</div>\n        </div>\n      </div>\n    {/if}\n  </div>\n  {/if}\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        dragging: false,\n        extent: [[0, 0],[0, 0]],\n        background: true,\n        round: false,\n        color: \"rgb(255, 130, 0)\",\n        enableDragging: true,\n        upListener: null,\n        moveListener: null,\n        cursor: 'grab',\n        clientWidth: 98,\n        clientHeight: 98\n      }\n    },\n    computed: {\n      left: ({clientWidth, extent}) => Math.min(clientWidth, Math.max(1e-6, extent[0][0] * clientWidth)),\n      right: ({clientWidth, extent}) => Math.min(clientWidth, extent[0][1] * clientWidth),\n      top: ({clientHeight, extent}) => Math.min(clientHeight, Math.max(1e-6, extent[1][0] * clientHeight)),\n      bottom: ({clientHeight, extent}) => Math.min(clientHeight, extent[1][1] * clientHeight),\n    },\n    oncreate() {\n      setTimeout(() => this.measure(), 10);\n    },\n    methods: {\n      measure() {\n        this.set({\n          clientWidth: this.refs.root.offsetWidth,\n          clientHeight: this.refs.root.offsetHeight,\n        })\n      },\n      up() {\n        const {upListener, moveListener} = this.get();\n        window.removeEventListener(\"pointermove\", moveListener);\n        window.removeEventListener(\"pointerup\", upListener);\n        this.set({cursor: \"grab\"});\n      },\n      down(event) {\n        event.preventDefault();\n        const {enableDragging, clientWidth, clientHeight} = this.get();\n        if (enableDragging) {\n          this.move(event);\n        }\n        const upListener = this.up.bind(this);\n        window.addEventListener(\"pointerup\", upListener);\n        const moveListener = this.move.bind(this);\n        window.addEventListener(\"pointermove\", moveListener);\n        this.set({upListener, moveListener, cursor: \"grabbing\"});\n      },\n      move(event) {\n        const {clientWidth, clientHeight} = this.get();\n        const gcx = event.offsetX / clientWidth; \n        const gcy = event.offsetY / clientHeight;\n        this.set({\n          gcx,\n          gcy,\n          startPos: {x: event.screenX, y: event.screenY},\n        });\n        this.fire(\"drag\", {gcx, gcy});\n      },\n    },\n  }\n</script>\n\n<style>\n  svg {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n  svg path {\n    fill: white;\n    fill-opacity: 0.7;\n  }\n  svg path.transparent {\n    fill-opacity: 0;\n  }\n  .root {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n  }\n  .reticle {\n    top: 0;\n    left: 0;\n    position: absolute;\n    border: solid 1px black;\n    border-width: 2px;\n    box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);\n    box-sizing: border-box;\n    background: rgba(0, 0, 0, 0);\n    border-radius: 4px;\n    pointer-events: none;\n  }\n  .reticle.round {\n    border-radius: 50%;\n  }\n  .annotationTabParent {\n    position: absolute;\n    left:0px;\n  }\n  .annotationTab {\n    width: 16px;\n    height: 16px;\n    left: -16px;\n    top: -8px;\n    position: absolute;\n    border-radius: 3px 0px 0px 3px;\n  }\n  p.annotation {\n    font-size: 12px;\n    top: 0px;\n    left: 4px;\n    color: white;\n    position: absolute;\n    text-align: center;\n    line-height: 1em;\n  }\n</style>\n",
    "<div ref:root class=\"{background ? 'background' : ''} {border ? 'border' : ''}\">\n  <Radar bind:ready>\n    <Placeholder {aspectRatio}>\n      {#if ready}\n        <img ref:image src=\"{src}\" alt=\"{alt}\" style={style}>\n      {:else}\n        <Loading />\n      {/if}\n    </Placeholder>\n  </Radar>\n</div>\n\n<script>\n  export default {\n    components: {\n      Radar: \"./Radar.html\",\n      Loading: \"./Loading.html\",\n      Placeholder: \"./Placeholder.html\"\n    },\n    data() {\n      return {\n        ready: false,\n        src: \"\",\n        alt: \"\",\n        style: \"\",\n        display: \"block\", //\"inline\", \"inline-block\", \"block\"\n        aspectRatio: 1, // width/height\n        border: true,\n        background: false,\n      }\n    }\n  }\n</script>\n\n<style>\nref:root {\n  contain: content;\n  overflow: hidden;\n}\n.background {\n  background: rgba(0, 0, 0, 0.05);\n}\n.border {\n  border: 1px solid rgba(0, 0, 0, 0.1);\n}\nref:image {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n</style>",
    "<div class=\"root\" style=\"display: {display}; padding-bottom: {100 / aspectRatio}%\">\n  <div class=\"container\">\n    <slot></slot>\n  </div>\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        display: \"block\",\n        aspectRatio: 1,\n        clientWidth: 0,\n        \n      }\n    },\n    computed: {\n      // width: ({clientWidth}) => clientWidth,\n      // height: ({width, aspectRatio}) => width / aspectRatio\n    }\n  }\n</script>\n\n<style>\n.root {\n  position: relative;\n  box-sizing: border-box;\n}\n.container {\n  position: absolute;\n  box-sizing: border-box;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n</style>",
    "\n<div style=\"height: {height}px;\">\n  <canvas ref:canvas width={gridSize} height={gridSize} style=\"width: 100%;\"></canvas>\n</div>\n\n<script>\nimport { load } from 'lucid-components';\nimport classesToKeep from './classesToKeep.js';\n\n\nimport inceptionv1_mixed3a from \"../public/_cache/inceptionv1_mixed3a/inceptionv1_mixed3a.json\";\nimport inceptionv1_mixed3b from \"../public/_cache/inceptionv1_mixed3b/inceptionv1_mixed3b.json\";\nimport inceptionv1_mixed4a from \"../public/_cache/inceptionv1_mixed4a/inceptionv1_mixed4a.json\";\nimport inceptionv1_mixed4b from \"../public/_cache/inceptionv1_mixed4b/inceptionv1_mixed4b.json\";\nimport inceptionv1_mixed4c from \"../public/_cache/inceptionv1_mixed4c/inceptionv1_mixed4c.json\";\nimport inceptionv1_mixed4d from \"../public/_cache/inceptionv1_mixed4d/inceptionv1_mixed4d.json\";\nimport inceptionv1_mixed4e from \"../public/_cache/inceptionv1_mixed4e/inceptionv1_mixed4e.json\";\nimport inceptionv1_mixed5a from \"../public/_cache/inceptionv1_mixed5a/inceptionv1_mixed5a.json\";\nimport inceptionv1_mixed5b from \"../public/_cache/inceptionv1_mixed5b/inceptionv1_mixed5b.json\";\n\nconst configs = {\n  inceptionv1_mixed3a: inceptionv1_mixed3a,\n  inceptionv1_mixed3b: inceptionv1_mixed3b,\n  inceptionv1_mixed4a: inceptionv1_mixed4a,\n  inceptionv1_mixed4b: inceptionv1_mixed4b,\n  inceptionv1_mixed4c: inceptionv1_mixed4c,\n  inceptionv1_mixed4d: inceptionv1_mixed4d,\n  inceptionv1_mixed4e: inceptionv1_mixed4e,\n  inceptionv1_mixed5a: inceptionv1_mixed5a,\n  inceptionv1_mixed5b: inceptionv1_mixed5b,\n}\n\nexport default {\n  data() {\n    return {\n      root: \"https://storage.googleapis.com/activation-atlas/build\",\n      model: \"inceptionv1\",\n      layerName: \"mixed4d\",\n      grid: 1,\n      layout: 0,\n      gridSize: 10,\n      classHeatmap: -1,\n      icons: [],\n      clientWidth: 45\n    };\n  },\n  computed: {\n    height: ({clientWidth}) => clientWidth,\n    id: ({model, layerName}) => model + \"_\" + layerName\n  },\n  oncreate() {\n    const {root, id, grid} = this.get();\n    const config = configs[id]\n    // console.log(\"config: \", config)\n    if (config.class_filter == null) { config.class_filter = \"None\" }\n    if (config.filter == null) { config.filter = \"None\" }\n    if (!Array.isArray(config.layout)) {config.layout = [config.layout]}\n    if (!Array.isArray(config.layer)) {config.layer = [config.layer]}\n    if (!Array.isArray(config.filter)) {config.filter = [config.filter]}\n    this.set({gridSize: config.grid_size[grid], layerName: config.layer[0]})\n    const url = `${root}/${id}/web/web--grid_size=${config.grid_size[grid]}--layout=${config.layout[0]}--class_filter=${config.class_filter}--filter=${config.filter[0]}--layer=${config.layer[0]}--model=${config.model}--sample_images=${config.sample_images}--sample_type=${config.sample_type}.json`\n    // console.log(\"config\", config)\n    load(url).then(web => {\n      // console.log(\"web\", web)\n      this.set({icons: web});\n      this.render();\n    });\n  },\n  onupdate({changed}) {\n    if (changed.classHeatmap) {\n      this.render();\n    }\n  },\n  methods: {\n    render() {\n      const {grid, gridSize, icons, classHeatmap, layerName} = this.get();\n      const context = this.refs.canvas.getContext('2d');\n      let imageData = context.getImageData(0, 0, gridSize, gridSize);\n      let data = imageData.data;\n      let flipX = false;\n      let flipY = false;\n      switch (layerName) {\n        case \"mixed4a\":\n          flipX = true;\n          flipY = true;\n          break;\n        case \"mixed4d\":\n          flipX = true;\n          flipY = false;\n          break;\n        case \"mixed5a\":\n          flipX = true;\n          flipY = false;\n          break;\n        case \"mixed5b\":\n          flipX = true;\n          flipY = false;\n          break;\n      }\n      // for (var i = 0; i < data.length; i += 4) {\n        // data[i] = 100;\n        // data[i + 1] = 100;\n        // data[i + 2] = 100;\n        // data[i + 3] = 255;\n      // }\n      for (const icon of icons) {\n        let heatmapMultiplier = 1.0;\n        if (classHeatmap > -1) {\n          let ci = classesToKeep.indexOf(classHeatmap);\n          let value = Math.max(0, icon.f[ci]);\n          heatmapMultiplier = Math.max(0.1, value * 20);\n          // console.log(ci, value)\n        }\n        const y = flipX ? (gridSize - icon.x - 1) : icon.x; //x,y switched on purpose \n        const x = flipY ? (gridSize - icon.y - 1) : icon.y; //x,y switched on purpose\n        // data[y * gridSize * 4 + x * 4 + 0] = (heatmapMultiplier) * 255 * 20;\n        // data[y * gridSize * 4 + x * 4 + 1] = (heatmapMultiplier) * 130 * 20;\n        // data[y * gridSize * 4 + x * 4 + 2] = (heatmapMultiplier) * 1 * 20;\n        data[y * gridSize * 4 + x * 4 + 3] = 40 + (gridSize > 20 ? 0.0008 : 0.00015) * gridSize * gridSize * (icon.n / Math.pow((grid + 1), 2)) * heatmapMultiplier;\n      }\n      \n      context.putImageData(imageData, 0, 0);\n    }\n  }\n}\n\n\n</script>\n<style>\ncanvas {\n  image-rendering: pixelated;\n}\n</style>",
    "<div>\n  <span>Loading …</span>\n</div>\n\n<style>\ndiv {\n  display: table;\n  text-align: center;\n  color: rgba(0, 0, 0, 0.3);\n  font-size: 12px;\n  line-height: 100%;\n  height: 100%;\n  width: 100%;\n}\nspan {\n  display: table-cell;\n  vertical-align: middle;\n}\n</style>"
  ],
  "names": [],
  "mappings": "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"
}